rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Rules for the 'users' collection
    match /users/{userId} {
      // Allow users to read, update, and delete their own document.
      // Allow any authenticated user to create their user document (e.g., during signup).
      allow read, update, delete: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null; // For initial signup, or can be request.auth.uid == userId
    }

    // Rules for the 'rideRequests' collection
    match /rideRequests/{rideRequestId} {
      // Allow customers to create ride requests
      allow create: if request.auth != null &&
                       request.resource.data.customerId == request.auth.uid;

      // Allow authenticated users to read ride requests
      allow read: if request.auth != null;

      // Allow customers to update (e.g., cancel their own ride before a driver is assigned or if allowed by app logic)
      // Allow drivers to update (accept, decline, progress, complete, cancel)
      // DRIVER UPDATES (accept, decline, progress, complete, cancel by driver) ARE NOW HANDLED BY CLOUD FUNCTIONS.
      // Customer can only cancel their own ride under specific conditions.
      allow update: if request.auth != null && (
        // Customer can update their own ride (e.g., to cancel if status allows)
        (resource.data.customerId == request.auth.uid &&
          request.resource.data.status == 'cancelled_by_customer' &&
          (resource.data.status == 'pending_match' || resource.data.status == 'pending_driver_acceptance' || resource.data.status == 'accepted') // Customer can cancel even if accepted, before pickup
        ) ||
        // Case 2: Customer rating the driver after ride completion
        (resource.data.customerId == request.auth.uid &&
          resource.data.status == 'completed' &&
          true ) // Temporarily bypass field validation for rating to isolate the issue
			);
       // Allow update by the service account (for denormalization by Cloud Functions)
      allow update: if request.auth.uid == 'YOUR_SERVICE_ACCOUNT_UID' && (
        // The Cloud Function can only update customer details and any other denormalized fields
        request.writeFields.hasOnly(['customerName', 'customerProfileImageUrl', 'customerDetails'])
      );
      // Prevent deletion of ride requests
      allow delete: if false;
    }

    // Rules for the 'appConfiguration' collection
    match /appConfiguration/{configId} {
      // Allow read access to the service account used by Cloud Functions
      // This typically uses 'service account' authentication.
      // You might restrict this further if needed, but for config, read is usually safe.
      allow read: if true; // Or a more specific condition if needed
      // Prevent client apps from writing to this configuration
      allow create, update, delete: if false; // Or restrict to specific admin UIDs if needed
    }

    // Rules for the 'rideHistory' collection
    match /rideHistory/{rideHistoryId} {
      // Allow customers and drivers to read their ride history
      allow read: if request.auth != null && (
        resource.data.customerId == request.auth.uid ||
        resource.data.driverId == request.auth.uid
      );

      // Only backend can create ride history
      allow create: if false;

      // Only backend can update or delete ride history
      allow update, delete: if false;
    }
    
     // Rules for the 'scheduledRides' collection
    match /scheduledRides/{scheduledRideId} {
      // Allow customers and drivers to create scheduled rides
      allow create: if request.auth != null &&
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['Customer', 'Driver', 'Both'];

      // Allow authenticated users to read scheduled rides
      allow read: if request.auth != null;

      // Allow the customer who created the scheduled ride to update it (you might want to refine this)
      allow update: if request.auth != null &&
          resource.data.customerId == request.auth.uid;

      // Allow the customer who created the scheduled ride to delete it (you might want to refine this)
      allow delete: if request.auth != null &&
          resource.data.customerId == request.auth.uid;
      }

    // Kijiwe Collection
    match /kijiwe/{kijiweId} {
      // Allow any authenticated user to read Kijiwe information (e.g., for the dropdown)
      allow read: if request.auth != null;
      // Allow an authenticated user to create a new Kijiwe
      // (The driver becomes the adminId of this new Kijiwe)
      allow create: if request.auth != null && request.resource.data.adminId == request.auth.uid;
      
      // Allow updates by admin, or for drivers to manage their presence in the queue of their assigned Kijiwe,
      // or add themselves to permanentMembers of their assigned Kijiwe.
      allow update: if request.auth != null && (
      resource.data.adminId == request.auth.uid || // Admin can update
        // Case 1: Admin of the Kijiwe can update anything
        resource.data.adminId == request.auth.uid ||

        // Case 2: Driver updating their own Kijiwe's queue or adding themselves to permanentMembers
        (
          // Verify user is a driver and this kijiweId matches their profile's kijiweId
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'Driver' &&
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.driverProfile.kijiweId == kijiweId &&

          // Check that only 'queue' or 'permanentMembers' are being written to.
          // This handles arrayUnion/arrayRemove operations correctly.
          (
            (request.writeFields.size() == 1 && request.writeFields[0] == 'queue') ||
            (request.writeFields.size() == 1 && request.writeFields[0] == 'permanentMembers')
            // If updating both 'queue' and 'permanentMembers' simultaneously by a driver was a requirement,
            // this part of the rule would need to be adjusted.
          )
        )
      );
    }
  }
}
